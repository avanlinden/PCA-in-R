---
title: "PCA in R"
author: "Abby Vander Linden"
date: "3/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Principal Components Analysis

PCA is an exploratory analysis that allows you to identify the ordination axes that explain the greatest amount of variation among interrelated variables in your data. For PCA, you need continuous data (or something that your field considers continuous, like emotion intensity on a scale of 1-100 -- hi Madi!). There are other ordination analyses you can do with non-continuous data but we'll start with PCA.

We'll use a subset of the linear morphometric dataset from my paper on cervical vertebra shape in ruminant mammals -- strangely enough, the only paper I've published so far where I *didn't* include a PCA! But the data are a useful PCA practice set because I have many linear measurements of different vertebral features across 40 species, including males and females as well as members of different "fighting behavior" categories. 

My question is: do species that ram horns head-on (ighorn sheep, bison, etc) have differently shaped cervical vertebrae than species that lock horns and wrestle (antelope, deer, etc)? My first step when analyzing these data is to peform a PCA in order to visualize the major axes of variation among and across these groups.

## Tidyverse library

The first step is to install the tidyverse packages if you haven't already, and then load the library. Tidyverse contains a lot of useful packages, including dplyr and ggplot2, which we will use here.

```{r}
library(tidyverse)
```

## Loading and Tidying Data

Load the ruminant vertebral morphology data set and format it as a tibble (a tibble is dplyr's version of a dataframe), then take a look at it.

```{r}
vertData_tbl <- as_tibble(read.csv("ruminant_vert_morph_data.csv"))

vertData_tbl
```

These data are a subset of my ruminant mammal linear morphometrics dataset -- basically, I spent months in museum basements measuring different parts of seven cervical vertebrae from 100+ individual sheep, goat, deer, and antelope skeletons. The measurement data (value) are identified by museum catalog numbers (catNum) and then by vertebra number (C2-C7), as well as which particular feature was measured (measure). I then joined the measurement data with other data for each individual, including body mass, sex, and fighting style. This subset includes animals from two fighting styles: ram and wrestle. 

Before we do PCA, we can filter and tidy the data a bit with some easy-breezy dplyr functions. I like to use the pipe function (denoted by %>% ) from the magrittr package, because it lets me manipulate tibbles one step at a time without saving a new object every time. The ' %>% ' operator can be read as 'and then'; e.g., take an object 'and then' do something to it, 'and then' do something else to it. 

```{r}
vertData_tbl %>%  # take our vertData_tbl 'and then' do the following:
  select(-X,-type, logBMSS) %>%  #remove columns we don't need for PCA
  filter(!is.na(value)) %>%  #remove NAs -- not necessary, prcomp will handle it, but nice to do
  filter(vertebra == 'C2') %>% #filter the data by row so that we're using just the measurements from the second cervical vertebra (C2)
  mutate(measureName = str_replace_all( #add a new column with full names of measurements for non-morphologists
    measure,
    c("CH" = "centrumHeight", 
      "CL" = "centrumLength", 
      "CW" = "centrumWidth",
      "DL" = "densLength",
      "DW" = "densWidth",
      "NSL" = "neuralSpineLength",
      "NSLA" = "neuralSpineLeverArm",
      "preZD" = "preZygDist",
      "TPLA" = "transProcessLeverArm"
      )
  )) 
```

The pipe function allows me to tidy my data step by step without saving or rewriting the initial dataframe each time, so I can make sure all my filters work the way I want to. Once I have it in the version I want, I'll save it as a new object that we can use for the PCA.

```{r}
vertData <-
  vertData_tbl %>%  #all the same stuff as above, but now saving it as a new tibble
  select(-X, -type, logBMSS) %>%
  filter(!is.na(value)) %>%
  filter(vertebra == 'C2') %>% #
  mutate(measureName = str_replace_all(measure,
    c(
      "CH" = "centrumHeight",
      "CL" = "centrumLength",
      "CW" = "centrumWidth",
      "DL" = "densLength",
      "DW" = "densWidth",
      "NSL" = "neuralSpineLength",
      "NSLA" = "neuralSpineLeverArm",
      "preZD" = "preZygDist",
      "TPLA" = "transProcessLeverArm"
    )
  )) %>%
  select(catNum, measureName,logValue, sex, spp, logBodyMass = logBMSS, fightStyle) #select columns we want in different order, rename body mass column

vertData #view the new tibble
```

We now have a tibble with 792 rows and 7 columns. If we want we can examine the tibble with the function **distinct** to see how many variables we have and how many species we have.

```{r}
vertData %>% 
  distinct(measureName)

vertData %>% 
  distinct(spp)

vertData %>% 
  distinct(catNum)
```
So we have 88 individuals, 40 species, and 9 variables.

## PCA with prcomp

Now we have a reasonably tidy dataset, it's time to do the PCA! 

The first step is to go from our tidy narrow dataframe to a wide dataframe where each vertebral measurement (each variable we want to include in our PCA) has its own column. This is simple with the dplyr function **spread**.

Note: we'll use the log10 transformed measurements, since PCA assumes each variable has a normal distribution. 

```{r}
wideData <- vertData %>% 
  spread(key = measureName, value = logValue) #now each specimen has its own row with 9 vertebral measurements

wideData
```

The PCA function I use is **prcomp** from base R. I assign the PCA results to a new object, vertPCA, and specify that the function use the measurement variables 6:14 in the wide column

```{r}
vertPCA <- prcomp(wideData[,6:14])
```

I know, that was a lot of buildup. Let's look at the PCA results!

```{r}
summary(vertPCA)
```

This gives us a quick look at the standard deviation and proportion of variance explained by each component. In our case, since the measurement variables are not corrected by size and the sample has everything from pygmy antelopes to bison, PC1 explains ~90% of the variance and is dominated by size. This is expected for linear morphometric studies! PC2 explains ~5% of the variance, and PC3 explains ~3%, with each subsequent PC decreasing after that. All 9 PCs together explain 100% of the variance.

A quick way to visually inspect the variance explained by each PC is with a screeplot; also handy if you're using the "broken-stick" criterion to select PCs of most importance.

```{r}
screeplot(vertPCA)
```

We can also look at some of the output of the PCA:

```{r}
vertPCA$rotation # this is the matrix of variable loadings (eigenvectors)

vertPCA$x #this gives the PC scores for each specimen on each component (centered data multipled by the rotation matrix) (row numbers correspond to the initial data rows)

vertPCA$sdev #standard deviations of each PC, aka square roots of eigenvalues
```

## Plotting PCA Results

In my experience a lot of the value of a principal components analysis is that it allows you to visually explore axes of variation in your data. 

I like to rejoin my PC scores for each specimen with the original dataframe, so that I can include things like the species name, sex, etc in the visualizations: 

```{r}
vertPCscores <- vertPCA$x %>% 
  as_tibble() %>% #convert PC scores (vertPCA$x) to tibble
  add_column(catNum = wideData$catNum) %>%  #add catalog numbers from df used for PCA (unique identifiers)
  right_join(wideData, by = 'catNum') %>% #rejoin the PC scores to wideData tibble
  select(catNum:fightStyle, PC1:PC9) #select name, sex, fighting style columns and PC scores

vertPCscores
```

Now instead of our original measurement data, we have a dataframe of ruminant species with their principal component scores. On to plotting!

I like to pipe my dataframe into a ggplot2 graphic because I can add different filters or manipulations before the plot and adjust as need.

Here's a basic scatterplot of PC1 vs PC2:

```{r}
 vertPCscores %>%   
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point() +
  theme_classic()
```

Remember how PC1 accounts for ~90% of the variance? If we plot PC1 versus body mass, we see what's behind that.

```{r}
vertPCscores %>%   
  ggplot(aes(x = logBodyMass, y = PC1)) +
  geom_point() +
  theme_classic()
```

We could adjust for the influence of body size in our original data by regressing each measurement on body size and using the residuals from those regressions as input for the PCA. Or we can do like the old school morphologists used to do and just "discard" PC1 as a major axis of non-size shape variation, in favor of the subsequent PCs. 

